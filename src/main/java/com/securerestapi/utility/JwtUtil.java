package com.securerestapi.utility;

import java.time.Instant;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import java.text.ParseException;

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.JWSObject;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jose.jwk.source.ImmutableSecret;
import com.nimbusds.jose.proc.BadJOSEException;
import com.nimbusds.jose.proc.JWSKeySelector;
import com.nimbusds.jose.proc.JWSVerificationKeySelector;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import com.nimbusds.jwt.proc.ConfigurableJWTProcessor;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;

import lombok.var;

public abstract class JwtUtil {

	private static final int expireHourToken = 24;
	private static final int expireHourRefreshToken = 72;

	private static final String SECRET = "FBA898697394CDBC534E7ED86A97AA59F627FE6B309E0A21EEC6C9B130E0369C";

	public static String createAccessToken(String username, String issuer, List<String> roles) {
		try {
			JWTClaimsSet claims = new JWTClaimsSet.Builder().subject(username).issuer(issuer).claim("roles", roles)
					.expirationTime(Date.from(Instant.now().plusSeconds(expireHourToken * 3600))).issueTime(new Date())
					.build();

			Payload payload = new Payload(claims.toJSONObject());

			JWSObject jwsObject = new JWSObject(new JWSHeader(JWSAlgorithm.HS256), payload);

			jwsObject.sign(new MACSigner(SECRET));
			return jwsObject.serialize();
		} catch (JOSEException e) {
			throw new RuntimeException("Error to create JWT", e);
		}
	}

	public static String createRefreshToken(String username) {
		// like createAccessToken method, but without issuer, roles...
		try {
			JWTClaimsSet claims = new JWTClaimsSet.Builder().subject(username)
					.expirationTime(Date.from(Instant.now().plusSeconds(expireHourRefreshToken * 3600))).build();

			Payload payload = new Payload(claims.toJSONObject());

			JWSObject jwsObject = new JWSObject(new JWSHeader(JWSAlgorithm.HS256), payload);

			jwsObject.sign(new MACSigner(SECRET));
			return jwsObject.serialize();
		} catch (JOSEException e) {
			throw new RuntimeException("Error to create JWT", e);
		}
	}

	public static UsernamePasswordAuthenticationToken parseToken(String token)
			throws JOSEException, BadJOSEException, ParseException {

		byte[] secretKey = SECRET.getBytes();
		SignedJWT signedJWT = SignedJWT.parse(token);
		signedJWT.verify(new MACVerifier(secretKey));
		ConfigurableJWTProcessor<SecurityContext> jwtProcessor = new DefaultJWTProcessor<>();

		JWSKeySelector<SecurityContext> keySelector = new JWSVerificationKeySelector<>(JWSAlgorithm.HS256,
				new ImmutableSecret<>(secretKey));
		jwtProcessor.setJWSKeySelector(keySelector);
		jwtProcessor.process(signedJWT, null);
		JWTClaimsSet claims = signedJWT.getJWTClaimsSet();
		String username = claims.getSubject();
		var roles = (List<String>) claims.getClaim("roles");
		var authorities = roles == null ? null
				: roles.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
		return new UsernamePasswordAuthenticationToken(username, null, authorities);
	}
}

/**
 * The createAccessToken method creates a token with payload containing: subject (username), roles, issuer (who has requested the JWT), expirationTime set to 24 hours and issueTime, which is when the token was created.
 * The signature is encrypted with the HS256 algorithm and a secretKey aes-256-cfb, generated by https://asecuritysite.com/encryption/keygen.
 * The parseToken method is responsible for verifying the token signature and performing any checks on the payload, such as the token's expiration date. If the checks are successful, an instance of UsernamePasswordAuthenticationToken is returned that contains the username and roles associated with the user. 
 * This instance will then be added to the Spring Security context, with SecurityContextHolder.getContext().setAuthentication(authenticationToken).
 */